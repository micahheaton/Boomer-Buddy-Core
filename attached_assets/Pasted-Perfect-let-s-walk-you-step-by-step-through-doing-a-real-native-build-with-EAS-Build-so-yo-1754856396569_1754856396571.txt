Perfect—let’s walk you **step-by-step** through doing a *real native build* with **EAS Build** so you can install an APK on your Android phone and test call/SMS features (which Expo Go can’t do).

I’ll assume you have your RN project (or I’ll help you create one), and you’re working inside **Replit Core**. You don’t need Android Studio locally for this—**EAS builds in the cloud** and gives you a downloadable APK.

---

# Part 0 — What you’ll get at the end

* A **release APK** built by **EAS** (Expo Application Services).
* You’ll **download it to your Android** (or scan a QR) and install it.
* It will include your **Android native code** (e.g., `CallScreeningService`, SMS permissions, etc.), not just JavaScript.

---

# Part 1 — One-time setup

## A. Create a free Expo account

* Go to [https://expo.dev/signup](https://expo.dev/signup) and make an account (free is fine).

## B. Open your Replit shell

Use the Replit console in your project.

Install EAS CLI and Expo CLI:

```bash
npm i -g eas-cli expo-cli
```

Login:

```bash
eas login
# follow the prompt to login with your Expo account
```

> You only do this once per Repl.

---

# Part 2 — Make sure your project is “native-buildable”

You can use either:

* **Your existing React Native (bare) app**, or
* Create one quickly:

```bash
# from your Replit shell (in your repo folder)
npx react-native@latest init BoomerBuddy --template react-native-template-typescript
cd BoomerBuddy
npm install
```

(If you already have your app code, just `cd` into that folder instead.)

## A. Confirm Android folders exist

You should see `android/` in your project. If not, you’re in an Expo Managed app; for call/SMS features you need **native**. You can migrate with:

```bash
npx expo prebuild
```

…but for simplicity, **start from a bare RN app** if possible.

## B. Add your Android native pieces

Add at minimum:

* **Permissions** in `android/app/src/main/AndroidManifest.xml`:

```xml
<uses-permission android:name="android.permission.READ_CALL_LOG"/>
<uses-permission android:name="android.permission.ANSWER_PHONE_CALLS"/>
<uses-permission android:name="android.permission.READ_SMS"/>
<uses-permission android:name="android.permission.RECEIVE_SMS"/>
<uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>
<uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>
```

* **Call Screening Service** (example)
  `android/app/src/main/java/<yourpkg>/BoomerBuddyCallScreeningService.kt`:

```kotlin
package <your.package.name>

import android.telecom.CallScreeningService
import android.telecom.Call
import android.util.Log

class BoomerBuddyCallScreeningService : CallScreeningService() {
  override fun onScreenCall(callDetails: Call.Details) {
    val number = callDetails.handle?.schemeSpecificPart ?: ""
    Log.d("BoomerBuddy", "Incoming call: $number")
    // TODO: hook your risk engine here (local rules/model)
    val response = CallResponse.Builder()
    respondToCall(callDetails, response.build())
  }
}
```

* Register the service in `AndroidManifest.xml` (inside `<application>`):

```xml
<service
  android:name=".BoomerBuddyCallScreeningService"
  android:permission="android.permission.BIND_SCREENING_SERVICE"
  android:exported="true">
  <intent-filter>
    <action android:name="android.telecom.CallScreeningService"/>
  </intent-filter>
</service>
```

* Make sure your **applicationId** is set in `android/app/build.gradle` (e.g. `com.boomerbuddy`).

* Recommended SDKs in `android/build.gradle`:

```gradle
ext {
  minSdkVersion = 24
  targetSdkVersion = 34
  compileSdkVersion = 34
}
```

> You can add SMS default-role or other modules later; this gets you a **real APK** that can host those features.

---

# Part 3 — Configure EAS for a **generic React Native** build

Create `eas.json` in your project root:

```json
{
  "cli": { "version": ">= 5.0.0" },
  "build": {
    "release-apk": {
      "android": {
        "workflow": "generic",
        "gradleCommand": ":app:assembleRelease",
        "artifactPath": "android/app/build/outputs/apk/release/app-release.apk"
      }
    },
    "debug-apk": {
      "android": {
        "workflow": "generic",
        "gradleCommand": ":app:assembleDebug",
        "artifactPath": "android/app/build/outputs/apk/debug/app-debug.apk"
      }
    }
  }
}
```

Initialize EAS in the project:

```bash
eas build:configure
# Choose Android only for now
# When asked about credentials/keystore, let EAS generate and store it for you (easiest)
```

> EAS will keep your Android keystore securely (you can download a backup from their website later).

---

# Part 4 — Kick off a cloud build (APK)

From the project root:

```bash
# Quick installable build for sideloading
eas build -p android --profile release-apk
```

What happens:

* Your code is uploaded to EAS.
* Their cloud CI builds the APK with Gradle.
* You’ll get a **build page URL** and a **QR code**.

Open the URL in a browser:

* When it finishes, click **Download APK**.

---

# Part 5 — Install on your Android phone

### Option A: Download directly on phone

* Email yourself the APK link or open the EAS build page on your phone.
* Download the APK.
* Enable “Install unknown apps” for your browser if prompted.
* Install.

### Option B: Use ADB (USB)

* Connect phone via USB (with **USB debugging** enabled).
* In your local terminal:

```bash
adb install /path/to/app-release.apk
```

That’s it — **Boomer Buddy** is now on your phone.

---

# Part 6 — Give the app the right roles/permissions (for call tests)

On your Android phone:

1. **Grant permissions** (the app will prompt the first time you open it):

   * Phone, SMS, Notifications.
2. **Set as Call Screening app**:

   * Settings → Apps → Default apps → Caller ID & spam app (or “Call screening app”) → **Boomer Buddy**.
     (Exact menu names vary by OEM/Android version.)

> Now when calls come in, your `BoomerBuddyCallScreeningService` runs (you’ll see it in logs; you can expand to show notifications and labeling).

---

# Part 7 — Wire your backend and basic UI (minimal but real)

Inside your RN app, add a quick feed fetch to prove server integration:

`src/api.ts`:

```ts
import axios from 'axios';
const API_BASE = 'https://api.boomerbuddy.net'; // your Replit backend
export const getFeeds = async () => (await axios.get(`${API_BASE}/v1/feeds.json`)).data;
```

`App.tsx`:

```tsx
import React, { useEffect, useState } from 'react';
import { SafeAreaView, Text, FlatList } from 'react-native';
import { getFeeds } from './src/api';

export default function App() {
  const [items, setItems] = useState<any[]>([]);
  useEffect(() => { getFeeds().then(setItems).catch(console.warn); }, []);
  return (
    <SafeAreaView style={{ padding: 16 }}>
      <Text style={{ fontSize: 22, fontWeight: '700', marginBottom: 8 }}>
        Boomer Buddy
      </Text>
      <FlatList
        data={items}
        keyExtractor={(_, i) => String(i)}
        renderItem={({ item }) => <Text style={{ marginBottom: 6 }}>{item.title}</Text>}
      />
    </SafeAreaView>
  );
}
```

Rebuild with EAS (same command), reinstall the APK, open it—your **feeds** should render. Now you know the **app ↔ backend** path works.

---

# Part 8 — Common pitfalls & fixes

* **Build fails on EAS with Gradle/JDK errors**
  EAS Cloud uses compatible JDKs; if you pinned a very old Gradle plugin, update `android/gradle/wrapper/gradle-wrapper.properties` to a recent Gradle (e.g., 8.x) and the Android Gradle Plugin in `android/build.gradle` (e.g., `com.android.tools.build:gradle:8.1.4`).

* **“Package name” collision**
  Change `applicationId` in `android/app/build.gradle` to a unique value, e.g., `com.boomerbuddy.app`.

* **App installs but call screen service doesn’t trigger**
  Ensure you set the **Caller ID/Spam app** default to Boomer Buddy and granted **Phone** permission.

* **Expo asks for an app.json/app.config**
  For **generic RN**, it’s optional. EAS uses your Android Gradle config. If prompted, add a minimal `app.json` with `"name"` and `"slug"`.

---

# Part 9 — iOS (for later)

When you’re ready:

* Join Apple Developer Program (\$99/year).
* In the same project, run:

```bash
eas build -p ios
```

* EAS will guide you through creating/using certificates.
* You’ll distribute via **TestFlight**. (iOS call/SMS needs **Call Directory** and **SMS Filter** extensions—done in Xcode targets; EAS will still build them in the cloud.)

---

# Part 10 — Your next mile (so it feels “real”)

* Add a **notification** in your CallScreeningService when risk is medium/high.
* Add a small **RiskEngine** in Kotlin reading a `rules.json` from `assets/`.
* Create a **Settings** screen for permissions & “Set as call screening app” help.
* Implement **default SMS role** (optional) or show a “Report SMS” screen in RN.

When you want, I can give you:

* A **drop-in RiskEngine** (Kotlin) + `rules.json`
* A **notification helper** for incoming call warnings
* A ready **eas.json** + scripted commands to cut builds in one click

---

## TL;DR commands you’ll actually run

From your Replit shell (inside your RN project):

```bash
eas login
eas build:configure
# accept defaults; let EAS generate Android keystore

# build a sideloadable APK:
eas build -p android --profile release-apk
```

Then download the APK from the EAS build page and install it on your phone.

---

If you hit *anything* weird, paste me the EAS **build page link** or the **error snippet**, and I’ll tell you exactly what to change. Once this APK is working on your phone, we’ll layer in the call-risk notifications and SMS hooks next.
